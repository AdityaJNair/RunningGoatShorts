package visual;
import pt.queues.FifoLifoQueue;
import pt.runtime.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import data_structures.AdjacencyList;
import data_structures.NodeObject;
import data_structures.UserOptions;
import org.graphstream.graph.Edge;
import org.graphstream.graph.Graph;
import org.graphstream.graph.Node;
import org.graphstream.graph.implementations.SingleGraph;
import javax.swing.*;

public class ParallelSearchVisualTree extends SolutionTreeVisual{
	
	int semaphore = UserOptions.getInstance().getParallelThreads(); //Threads
	FifoLifoQueue<List<NodeObject>> bestScheduleThreaded = new FifoLifoQueue<List<NodeObject>>();
	FifoLifoQueue<Integer> bestTimeThreaded= new FifoLifoQueue<Integer>();
	List<String> sourceNodes = inputGraph.getSourceNodes();
	TaskIDGroup taskGroup = new TaskIDGroup(UserOptions.getInstance().getParallelThreads()+5);
	/**
	 * @param inputGraph
	 */
	public ParallelSearchVisualTree(AdjacencyList inputGraph) {
		super(inputGraph);
		bestTimeThreaded.addGlobal(Integer.MAX_VALUE);
//		bestScheduleThreaded.addGlobal(null);
	}
	
	public void recursiveMethod(NodeObject currentNode, List<String> nodesToCheck, boolean isSubtask){
		
		// Exit condition for exiting recursion
		if(nodesToCheck.size() == 0){
			validScheduleCount++;
			validScheduleCountLabel.setText("Valid Schedules Discovered: "+Long.toString(validScheduleCount));
			// Calculate time
			// Compare with minimumTime to see if this solution is better
			if(maxTimeAtPoint(currentNode) < minimumTime) {
				bestTimeCount++;
				//when tree all the way down, and the time is lower than the global flag, set the new time
				//and set the new schedule to it
				for (Edge e : bestTimeTree.getEdgeSet()) {
					e.addAttribute("ui.style", "fill-color: rgb(0,0,0);");
				}
				minimumTime = maxTimeAtPoint(currentNode);
				bestTimeLabel.setText("Current Best Time: " + maxTimeAtPoint(currentNode));
				bestTimeCountLabel.setText("Faster Schedules Found: " + Long.toString(bestTimeCount));
				bestSchedule = currentNode.getCurrentPath();
				String oldNode = new String();
				String newNode = new String();
				int i = 0;
				Edge e;
				String bestPath = new String();
				for (NodeObject node : currentNode.getCurrentPath()) {
					if (node.getNodeName().equals("rootNode"))
						continue;
					newNode += node.getNodeName() + node.getProcessor();
					if (bestTimeTree.getNode(newNode) == null) {
						Node n = bestTimeTree.addNode(newNode);

//						n.addAttribute("ui.label", node.getNodeName() + "(" + node.getProcessor() + ")");
                        n.addAttribute("ui.label", newNode);
						n.addAttribute("layout.frozen");

						n.addAttribute("y", -i * 15);

						n.addAttribute("x", nid);
					}
					if (i > 0) {
						bestTimeTree.removeEdge(newNode, oldNode);
						e = bestTimeTree.addEdge(Integer.toString(nid), newNode, oldNode);
						e.setAttribute("ui.style", "fill-color:red;");

					}

					oldNode = newNode;
					i++;
					nid++;
					//SPEED FACTOR: lower=faster
					try{ 
						Thread.sleep(50);
					}catch (Exception e2){
						
					}
					bestPath += node.getNodeName() + "(" + (node.getProcessor() + 1) + ") ";
				}
				bestTimeScheduleLabel.setText("Best Path: " + bestPath);
			} else if(maxTimeAtPoint(currentNode) == minimumTime){
				equalBestTimeCount++;
				equalBestTimeCountLabel.setText("Duplicate Schedules at Current Optimal Time Found: "+Long.toString(equalBestTimeCount));
			}
			return;
			}
		
		// heuristics for pruning the tree
		if(minimumTime != Integer.MAX_VALUE){
			//if the time of current node but has not finished path is greater than optimal path which has finished dont bother looking
			if(maxTimeAtPoint(currentNode) >= minimumTime){
				return;
			}
		
			if(calculateLowerBound(currentNode, nodesToCheck) >= minimumTime){
				return;
			}
		}
		
		TaskID newTask = null;
		List<String> legalNodes = new ArrayList<String>();
		
		// collect the list of nodes we can go to
		for(String nodeToCheckStr : nodesToCheck){
			if(isValidOption(nodeToCheckStr, nodesToCheck)){
				legalNodes.add(nodeToCheckStr);
			}
		}
		int count =0;
		if(legalNodes.size() == 1){
			// sequential
			for(int i=0 ; i<numberofProcessors ; i++){
				NodeObject newNode = createNextNode(currentNode, legalNodes.get(0), i);
				//copy the nodesToCheck list and need to remove the current node from it for recursion
				List<String> newUpdatedListWithoutCurrentNode = new LinkedList<String>(nodesToCheck);
				newUpdatedListWithoutCurrentNode.remove(legalNodes.get(0));
				nodeNumber++;
				
				recursiveMethod(newNode, newUpdatedListWithoutCurrentNode, isSubtask);
			}
			
		} else {

			for(String nodeToCheckStr : legalNodes){

				for(int i = 0 ; i <numberofProcessors; i++){
					if(currentNode.getTimeWeightOnEachProcessor()[i] == 0){
						count++;
					}
				}
				int killtree = 0;
				if(count >= 2){
					killtree = count -1;
				}
				for(int j = 0; j < (numberofProcessors - killtree); j++){
					NodeObject newNode = createNextNode(currentNode, nodeToCheckStr, j);
					
					//copy the nodesToCheck list and need to remove the current node from it for recursion
					List<String> newUpdatedListWithoutCurrentNode = new LinkedList<String>(nodesToCheck);
					newUpdatedListWithoutCurrentNode.remove(nodeToCheckStr);
					nodeNumber++;
					
					if(isSubtask){
						recursiveMethod(newNode, newUpdatedListWithoutCurrentNode, true);
						continue;
					}
					// check if new thread can be created
					if(semaphore == 0){
						// can't mke any more threads
						recursiveMethod(newNode, newUpdatedListWithoutCurrentNode, false);
					} else {
						// create new thread
						semaphore--;
						newTask = intermediateMethod(newNode, newUpdatedListWithoutCurrentNode);
						
						taskGroup.add(newTask);
					}
				}
			}
		}
		if(isSubtask){
			return;
		}
		try{
			//taskGroup.waitTillFinished();
		}catch(Exception e){
			e.printStackTrace();
		}
	}
	
	TASK private void intermediateMethod(NodeObject currentNode, List<String> nodesToCheck){
		recursiveMethod(currentNode, nodesToCheck, true);
		semaphore++;
		
	}
	
	private NodeObject createNextNode(NodeObject currentNode, String nodeToCheckStr, int processorNumber){
		//create a newpath that is the same as current which includes the currentNode as well
		//same thing but only copying the processor array --not checking for times at this place
		ArrayList<NodeObject> nextPath = new ArrayList<NodeObject>(currentNode.getCurrentPath());
		int[] processorArray = Arrays.copyOf(currentNode.getTimeWeightOnEachProcessor(), currentNode.getTimeWeightOnEachProcessor().length);
		
		//initialising the fields for the new NodalObject to recurse through
		String newNodeName = nodeToCheckStr;
		int newProcessor = processorNumber;
		int nodalWeight = getNodalWeight(newNodeName);
		int newStartTime = checkProcessStartTimeTask(currentNode, newNodeName, newProcessor);
		int newEndTime = newStartTime+nodalWeight;
		processorArray[newProcessor] = newEndTime;
		
		//INITIALISE THE NEW NODE WITH UPDATED FIELDS
		NodeObject nextNode = new NodeObject(newProcessor, nextPath, newNodeName, processorArray, newStartTime, newEndTime);
		return nextNode;
	}
	
}